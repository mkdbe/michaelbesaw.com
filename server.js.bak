const express = require('express');
const fs = require('fs');
const path = require('path');
const exifr = require('exifr');
const geoip = require('geoip-lite');

const app = express();
const PORT = 3000;

// Directory where you'll store your photos
const PHOTOS_DIR = path.join(__dirname, 'photos');
// Directory for content files
const CONTENT_DIR = path.join(__dirname, 'content');
// Analytics log file
const ANALYTICS_FILE = path.join(__dirname, 'analytics.json');

// Exclude these IPs from analytics (add your own IP addresses here)
const EXCLUDED_IPS = [
    // Add your IP addresses here, one per line
    // '123.456.789.0',        // Example: Your home IP
    // '::1',                  // Localhost IPv6
    // '127.0.0.1',            // Localhost IPv4
    // '::ffff:127.0.0.1',     // Localhost IPv4 mapped to IPv6
];

// Initialize analytics file if it doesn't exist
if (!fs.existsSync(ANALYTICS_FILE)) {
    fs.writeFileSync(ANALYTICS_FILE, JSON.stringify({ visits: [] }));
}

// Analytics middleware - logs page views
function logVisit(req, res, next) {
    const userAgent = req.headers['user-agent'] || 'Unknown';
    
    // Get real IP from Nginx proxy headers
    const visitorIP = req.headers['x-forwarded-for'] || 
                      req.headers['x-real-ip'] || 
                      req.ip || 
                      req.connection.remoteAddress;
    
    // If multiple IPs in X-Forwarded-For, take the first one (actual visitor)
    const realIP = visitorIP.split(',')[0].trim();
    
    // Skip logging if IP is in exclusion list
    if (EXCLUDED_IPS.includes(realIP)) {
        return next();
    }
    
    // Detect device type
    let deviceType = 'Desktop';
    if (/mobile|android|iphone|ipad|tablet/i.test(userAgent)) {
        if (/ipad|tablet/i.test(userAgent)) {
            deviceType = 'Tablet';
        } else {
            deviceType = 'Mobile';
        }
    }
    
    // Detect operating system
    let os = 'Unknown';
    if (/windows/i.test(userAgent)) {
        os = 'Windows';
    } else if (/macintosh|mac os x/i.test(userAgent)) {
        os = 'macOS';
    } else if (/linux/i.test(userAgent) && !/android/i.test(userAgent)) {
        os = 'Linux';
    } else if (/android/i.test(userAgent)) {
        os = 'Android';
    } else if (/iphone|ipad|ipod/i.test(userAgent)) {
        os = 'iOS';
    } else if (/cros/i.test(userAgent)) {
        os = 'Chrome OS';
    }
    
    // Detect browser
    let browser = 'Unknown';
    if (/edg/i.test(userAgent)) {
        browser = 'Edge';
    } else if (/chrome/i.test(userAgent) && !/edg/i.test(userAgent)) {
        browser = 'Chrome';
    } else if (/safari/i.test(userAgent) && !/chrome/i.test(userAgent)) {
        browser = 'Safari';
    } else if (/firefox/i.test(userAgent)) {
        browser = 'Firefox';
    } else if (/opera|opr/i.test(userAgent)) {
        browser = 'Opera';
    } else if (/brave/i.test(userAgent)) {
        browser = 'Brave';
    }
    
    // Get geographic location from IP
    const geo = geoip.lookup(realIP);
    let location = 'Unknown';
    if (geo) {
        // Format: City, Region, Country
        const parts = [];
        if (geo.city) parts.push(geo.city);
        if (geo.region) parts.push(geo.region);
        if (geo.country) parts.push(geo.country);
        location = parts.length > 0 ? parts.join(', ') : geo.country || 'Unknown';
    }
    
    const visit = {
        timestamp: new Date().toISOString(),
        path: req.path,
        ip: realIP,
        location: location,
        userAgent: userAgent,
        device: deviceType,
        os: os,
        browser: browser,
        referer: req.headers['referer'] || 'Direct'
    };
    
    try {
        const data = JSON.parse(fs.readFileSync(ANALYTICS_FILE, 'utf8'));
        data.visits.push(visit);
        
        // Keep only last 10,000 visits to prevent file from getting huge
        if (data.visits.length > 10000) {
            data.visits = data.visits.slice(-10000);
        }
        
        fs.writeFileSync(ANALYTICS_FILE, JSON.stringify(data, null, 2));
    } catch (err) {
        console.error('Analytics logging error:', err);
    }
    
    next();
}

// Create photos directory if it doesn't exist
if (!fs.existsSync(PHOTOS_DIR)) {
    fs.mkdirSync(PHOTOS_DIR);
    console.log('Created photos directory at:', PHOTOS_DIR);
}

// Create content directory if it doesn't exist
if (!fs.existsSync(CONTENT_DIR)) {
    fs.mkdirSync(CONTENT_DIR);
    console.log('Created content directory at:', CONTENT_DIR);
    
    // Create sample about.txt file
    const sampleAbout = `<h2>About Michael Besaw</h2>
<p>Michael Besaw is a photographer specializing in landscape and nature photography. With over a decade of experience capturing the beauty of the natural world, Michael's work has been featured in numerous publications and exhibitions.</p>
<p>His photographic journey began in the mountains of Colorado, where he discovered a passion for documenting the interplay of light and landscape. Today, his portfolio spans diverse environments from coastal seascapes to desert vistas.</p>
<p>When not behind the camera, Michael enjoys hiking, environmental conservation work, and teaching photography workshops to aspiring photographers.</p>`;
    
    fs.writeFileSync(path.join(CONTENT_DIR, 'about.txt'), sampleAbout);
    console.log('Created sample about.txt file');
}

// Serve static files
app.use(express.static(__dirname));

// Serve photos with mobile optimization
app.use('/photos', (req, res, next) => {
    const userAgent = req.headers['user-agent'] || '';
    const isMobile = /mobile|android|iphone|ipad|tablet/i.test(userAgent);
    
    // For mobile, add cache headers for better performance
    if (isMobile) {
        res.setHeader('Cache-Control', 'public, max-age=31536000');
    }
    
    next();
}, express.static(PHOTOS_DIR, {
    maxAge: '1y',
    etag: true
}));

// Serve the portfolio page at root (with analytics)
app.get('/', logVisit, (req, res) => {
    res.sendFile(path.join(__dirname, 'portfolio.html'));
});

// API endpoint to get list of images with metadata
app.get('/api/images', async (req, res) => {
    try {
        const files = fs.readdirSync(PHOTOS_DIR);
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
        
        const imageFiles = files.filter(file => {
            const ext = path.extname(file).toLowerCase();
            return imageExtensions.includes(ext);
        });
        
        // Get metadata for each image
        const imagesWithMetadata = await Promise.all(
            imageFiles.map(async (file) => {
                const filepath = path.join(PHOTOS_DIR, file);
                let date = null;
                
                try {
                    // Try to extract EXIF date
                    const exif = await exifr.parse(filepath, {
                        pick: ['DateTimeOriginal', 'CreateDate', 'ModifyDate']
                    });
                    
                    if (exif) {
                        date = exif.DateTimeOriginal || exif.CreateDate || exif.ModifyDate;
                    }
                    
                    // Fallback to file modification date if no EXIF
                    if (!date) {
                        const stats = fs.statSync(filepath);
                        date = stats.mtime;
                    }
                } catch (err) {
                    // If EXIF fails, use file modification date
                    const stats = fs.statSync(filepath);
                    date = stats.mtime;
                }
                
                return {
                    url: `/photos/${file}`,
                    date: date ? date.toISOString() : null
                };
            })
        );
        
        res.json({ images: imagesWithMetadata });
    } catch (error) {
        console.error('Error reading photos directory:', error);
        res.status(500).json({ error: 'Failed to read photos directory' });
    }
});

// API endpoint to get about text
app.get('/api/about', (req, res) => {
    try {
        const aboutPath = path.join(CONTENT_DIR, 'about.txt');
        
        if (fs.existsSync(aboutPath)) {
            const content = fs.readFileSync(aboutPath, 'utf8');
            res.json({ content });
        } else {
            res.json({ content: '<h2>About</h2><p>About content not found. Please create content/about.txt file.</p>' });
        }
    } catch (error) {
        console.error('Error reading about.txt:', error);
        res.status(500).json({ error: 'Failed to read about content' });
    }
});

// API endpoint to track photo navigation
app.post('/api/track-nav', express.json(), (req, res) => {
    const userAgent = req.headers['user-agent'] || 'Unknown';
    
    // Get real IP from Nginx proxy headers
    const visitorIP = req.headers['x-forwarded-for'] || 
                      req.headers['x-real-ip'] || 
                      req.ip || 
                      req.connection.remoteAddress;
    
    const realIP = visitorIP.split(',')[0].trim();
    
    // Skip logging if IP is in exclusion list
    if (EXCLUDED_IPS.includes(realIP)) {
        return res.json({ success: true });
    }
    
    try {
        const data = JSON.parse(fs.readFileSync(ANALYTICS_FILE, 'utf8'));
        
        // Find the most recent visit from this IP
        const recentVisit = data.visits
            .filter(v => v.ip === realIP)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
        
        if (recentVisit) {
            // Increment navigation count for this visit
            recentVisit.navigations = (recentVisit.navigations || 0) + 1;
            fs.writeFileSync(ANALYTICS_FILE, JSON.stringify(data, null, 2));
        }
        
        res.json({ success: true });
    } catch (err) {
        console.error('Navigation tracking error:', err);
        res.status(500).json({ error: 'Failed to track navigation' });
    }
});

// API endpoint to track heartbeat (for session duration)
app.post('/api/heartbeat', express.json(), (req, res) => {
    const userAgent = req.headers['user-agent'] || 'Unknown';
    
    // Get real IP from Nginx proxy headers
    const visitorIP = req.headers['x-forwarded-for'] || 
                      req.headers['x-real-ip'] || 
                      req.ip || 
                      req.connection.remoteAddress;
    
    const realIP = visitorIP.split(',')[0].trim();
    
    // Skip logging if IP is in exclusion list
    if (EXCLUDED_IPS.includes(realIP)) {
        return res.json({ success: true });
    }
    
    try {
        const data = JSON.parse(fs.readFileSync(ANALYTICS_FILE, 'utf8'));
        
        // Find the most recent visit from this IP
        const recentVisit = data.visits
            .filter(v => v.ip === realIP)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
        
        if (recentVisit) {
            // Update last heartbeat time
            recentVisit.lastHeartbeat = new Date().toISOString();
            
            // Calculate duration in seconds
            const startTime = new Date(recentVisit.timestamp);
            const endTime = new Date(recentVisit.lastHeartbeat);
            recentVisit.duration = Math.floor((endTime - startTime) / 1000);
            
            fs.writeFileSync(ANALYTICS_FILE, JSON.stringify(data, null, 2));
        }
        
        res.json({ success: true });
    } catch (err) {
        console.error('Heartbeat tracking error:', err);
        res.status(500).json({ error: 'Failed to track heartbeat' });
    }
});

// Analytics dashboard endpoint
app.get('/analytics', (req, res) => {
    try {
        const data = JSON.parse(fs.readFileSync(ANALYTICS_FILE, 'utf8'));
        const visits = data.visits || [];
        
        // Calculate stats
        const totalVisits = visits.length;
        const last24h = visits.filter(v => {
            const visitTime = new Date(v.timestamp);
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            return visitTime > oneDayAgo;
        }).length;
        
        const last7days = visits.filter(v => {
            const visitTime = new Date(v.timestamp);
            const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            return visitTime > sevenDaysAgo;
        }).length;
        
        // Device type breakdown
        const deviceCounts = visits.reduce((acc, v) => {
            const device = v.device || 'Unknown';
            acc[device] = (acc[device] || 0) + 1;
            return acc;
        }, {});
        
        // OS breakdown
        const osCounts = visits.reduce((acc, v) => {
            const os = v.os || 'Unknown';
            acc[os] = (acc[os] || 0) + 1;
            return acc;
        }, {});
        
        // Browser breakdown
        const browserCounts = visits.reduce((acc, v) => {
            const browser = v.browser || 'Unknown';
            acc[browser] = (acc[browser] || 0) + 1;
            return acc;
        }, {});
        
        // Referrer breakdown (categorized)
        const referrerCounts = visits.reduce((acc, v) => {
            let source = 'Direct';
            if (v.referer && v.referer !== 'Direct') {
                if (/google/i.test(v.referer)) source = 'Google';
                else if (/bing/i.test(v.referer)) source = 'Bing';
                else if (/facebook|fb/i.test(v.referer)) source = 'Facebook';
                else if (/twitter|t\.co/i.test(v.referer)) source = 'Twitter';
                else if (/instagram/i.test(v.referer)) source = 'Instagram';
                else if (/linkedin/i.test(v.referer)) source = 'LinkedIn';
                else if (/reddit/i.test(v.referer)) source = 'Reddit';
                else source = 'Other';
            }
            acc[source] = (acc[source] || 0) + 1;
            return acc;
        }, {});
        
        // Bounce rate (visitors with 0 clicks and duration < 10 seconds)
        const bounced = visits.filter(v => 
            (!v.navigations || v.navigations === 0) && 
            (!v.duration || v.duration < 10)
        ).length;
        const bounceRate = totalVisits > 0 ? Math.round((bounced / totalVisits) * 100) : 0;
        
        // Top locations
        const locationCounts = visits.reduce((acc, v) => {
            const loc = v.location || 'Unknown';
            acc[loc] = (acc[loc] || 0) + 1;
            return acc;
        }, {});
        const topLocations = Object.entries(locationCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([loc, count]) => `${loc} (${count})`)
            .join('<br>');
        
        // Average session duration
        const visitsWithDuration = visits.filter(v => v.duration && v.duration > 0);
        const avgDuration = visitsWithDuration.length > 0 
            ? Math.floor(visitsWithDuration.reduce((sum, v) => sum + v.duration, 0) / visitsWithDuration.length)
            : 0;
        
        // Format duration in minutes:seconds
        function formatDuration(seconds) {
            if (!seconds || seconds === 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Recent visits (last 50)
        const recentVisits = visits.slice(-50).reverse();
        
        // Generate HTML dashboard
        const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Analytics - michaelbesaw</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 { font-weight: 300; letter-spacing: 2px; margin-bottom: 40px; }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-number {
            font-size: 36px;
            font-weight: 300;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 14px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .stat-box.wide {
            grid-column: span 2;
        }
        .stat-box.wide .stat-number {
            font-size: 14px;
            line-height: 1.6;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            font-weight: 500;
            opacity: 0.7;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        td {
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #fff;
            text-decoration: none;
            opacity: 0.7;
        }
        .back-link:hover { opacity: 1; }
        .refresh {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .refresh:hover { background: rgba(255,255,255,0.15); }
    </style>
</head>
<body>
    <a href="/" class="back-link">← Back to Portfolio</a>
    <h1>Analytics Dashboard</h1>
    
    <div class="stats">
        <div class="stat-box">
            <div class="stat-number">${totalVisits}</div>
            <div class="stat-label">Total Visits</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${last24h}</div>
            <div class="stat-label">Last 24 Hours</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${last7days}</div>
            <div class="stat-label">Last 7 Days</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${deviceCounts.Desktop || 0}</div>
            <div class="stat-label">Desktop</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${deviceCounts.Mobile || 0}</div>
            <div class="stat-label">Mobile</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${deviceCounts.Tablet || 0}</div>
            <div class="stat-label">Tablet</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${osCounts.Windows || 0}</div>
            <div class="stat-label">Windows</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${osCounts.macOS || 0}</div>
            <div class="stat-label">macOS</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${osCounts.Linux || 0}</div>
            <div class="stat-label">Linux</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${(osCounts.iOS || 0) + (osCounts.Android || 0)}</div>
            <div class="stat-label">Mobile OS</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${formatDuration(avgDuration)}</div>
            <div class="stat-label">Avg Duration</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${bounceRate}%</div>
            <div class="stat-label">Bounce Rate</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${browserCounts.Chrome || 0}</div>
            <div class="stat-label">Chrome</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${browserCounts.Safari || 0}</div>
            <div class="stat-label">Safari</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${browserCounts.Firefox || 0}</div>
            <div class="stat-label">Firefox</div>
        </div>
        <div class="stat-box">
            <div class="stat-number">${(browserCounts.Edge || 0) + (browserCounts.Opera || 0) + (browserCounts.Brave || 0)}</div>
            <div class="stat-label">Other Browsers</div>
        </div>
        <div class="stat-box wide">
            <div class="stat-number">
                ${Object.entries(referrerCounts)
                    .sort((a, b) => b[1] - a[1])
                    .map(([source, count]) => `${source} (${count})`)
                    .join(' • ')}
            </div>
            <div class="stat-label">Traffic Sources</div>
        </div>
        <div class="stat-box wide">
            <div class="stat-number">${topLocations || 'No data yet'}</div>
            <div class="stat-label">Top Locations</div>
        </div>
    </div>
    
    <h2 style="font-weight: 300; margin-top: 40px;">Recent Visits (Last 50)</h2>
    <button class="refresh" onclick="location.reload()">Refresh</button>
    
    <table>
        <tr>
            <th>Time (EST)</th>
            <th>Location</th>
            <th>Device</th>
            <th>OS</th>
            <th>Browser</th>
            <th>Duration</th>
            <th>Clicks</th>
            <th>Source</th>
            <th>IP</th>
        </tr>
        ${recentVisits.map(v => {
            let source = 'Direct';
            if (v.referer && v.referer !== 'Direct') {
                if (/google/i.test(v.referer)) source = 'Google';
                else if (/bing/i.test(v.referer)) source = 'Bing';
                else if (/facebook|fb/i.test(v.referer)) source = 'Facebook';
                else if (/twitter|t\.co/i.test(v.referer)) source = 'Twitter';
                else if (/instagram/i.test(v.referer)) source = 'Instagram';
                else source = 'Other';
            }
            const estTime = new Date(v.timestamp).toLocaleString('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            return `
            <tr>
                <td>${estTime}</td>
                <td>${v.location || 'Unknown'}</td>
                <td>${v.device || 'Unknown'}</td>
                <td>${v.os || 'Unknown'}</td>
                <td>${v.browser || 'Unknown'}</td>
                <td>${formatDuration(v.duration || 0)}</td>
                <td>${v.navigations || 0}</td>
                <td>${source}</td>
                <td>${v.ip}</td>
            </tr>
        `}).join('')}
    </table>
</body>
</html>
        `;
        
        res.send(html);
    } catch (error) {
        console.error('Error loading analytics:', error);
        res.status(500).send('Error loading analytics');
    }
});

app.listen(PORT, () => {
    console.log(`
========================================
Photography Portfolio Server Running
========================================
Server: http://localhost:${PORT}
Photos directory: ${PHOTOS_DIR}
Content directory: ${CONTENT_DIR}

Add your photos to the 'photos' folder and refresh the page!
Edit 'content/about.txt' to customize the About section.
========================================
    `);
});
